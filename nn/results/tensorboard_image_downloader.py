import json, base64, six


def _decode_blob_key(key):
    """Decode a blob key produced by `_encode_blob_key` into component fields.

    Args:
      key: a blob key, as generated by `_encode_blob_key`.

    Returns:
      A tuple of `(experiment_id, plugin_name, run, tag, step, index)`, with types
      matching the arguments of `_encode_blob_key`.
    """
    decoded = base64.urlsafe_b64decode(key + "==")  # pad past a multiple of 4.
    stringified = decoded.decode("ascii")
    (experiment_id, plugin_name, run, tag, step, index) = json.loads(
        stringified
    )
    return (experiment_id, plugin_name, run, tag, step, index)


def _encode_blob_key(experiment_id, plugin_name, run, tag, step, index):
    """Generate a blob key: a short, URL-safe string identifying a blob.

    A blob can be located using a set of integer and string fields; here we
    serialize these to allow passing the data through a URL.  Specifically, we
    1) construct a tuple of the arguments in order; 2) represent that as an
    ascii-encoded JSON string (without whitespace); and 3) take the URL-safe
    base64 encoding of that, with no padding.  For example:

        1)  Tuple: ("some_id", "graphs", "train", "graph_def", 2, 0)
        2)   JSON: ["some_id","graphs","train","graph_def",2,0]
        3) base64: WyJzb21lX2lkIiwiZ3JhcGhzIiwidHJhaW4iLCJncmFwaF9kZWYiLDIsMF0K

    Args:
      experiment_id: a string ID identifying an experiment.
      plugin_name: string
      run: string
      tag: string
      step: int
      index: int

    Returns:
      A URL-safe base64-encoded string representing the provided arguments.
    """
    # Encodes the blob key as a URL-safe string, as required by the
    # `BlobReference` API in `tensorboard/data/provider.py`, because these keys
    # may be used to construct URLs for retrieving blobs.
    stringified = json.dumps(
        (experiment_id, plugin_name, run, tag, step, index),
        separators=(",", ":"),
    )
    bytesified = stringified.encode("ascii")
    encoded = base64.urlsafe_b64encode(bytesified)
    return six.ensure_str(encoded).rstrip("=")


if __name__ == '__main__':
    import os
    import glob
    import urllib.parse
    import urllib.request

    key = 'WyIiLCJpbWFnZXMiLCIxM19pYz00X289YWRhbXdfd2Q9MUUtMDJfbHI9MUUtMDRfYnM9NTRfYz1sMT0xRSswMCIsImJlc3RfdmFsLzAiLDAsMl0'
    key2 = 'WyIiLCJpbWFnZXMiLCIxM19pYz00X289YWRhbXdfd2Q9MUUtMDJfbHI9MUUtMDJfYnM9NTRfYz1sMT0xRSswMCIsImJlc3RfdmFsLzAiLDAsMl0'
    key = 'WyIiLCJpbWFnZXMiLCIxM19pYz00X289YWRhbXdfd2Q9MUUtMDJfbHI9MUUtMDRfYnM9NTRfYz1sMT0xRSswMF9sMj0xRSswMCIsImJlc3RfdmFsLzAiLDAsMl0'
    key = 'WyIiLCJpbWFnZXMiLCIxM19pYz00X289YWRhbXdfd2Q9MUUtMDJfbHI9MUUtMDRfYnM9NTRfYz1sMT0xRSswMCIsImJlc3RfdmFsLzEiLDAsMl0'
    print(_decode_blob_key(key))
    print(_decode_blob_key(key2))
    # exit(0)

    basepath = os.path.join('c:', os.sep, 'Users', 'jarmi', 'data', 'reflections', 'experiments')
    tensorboard_path = os.path.join(basepath, 'tensorboard_realL2')

    tensorboard_server_address = 'http://localhost:6060/data/plugin/images/individualImage?blob_key={}'
    target_image_basepath = os.path.join(basepath, 'data', 'val', 'images')

    to_download = []

    import re

    basic = re.compile('.*adamw.*')

    dirs = glob.glob(os.path.join(tensorboard_path, '*'))
    tagname = 'best_val'
    for dir in dirs:
        basename = os.path.basename(dir)
        if len(to_download) > 0 and basename not in to_download:
            continue
        if basic.match(basename) is None:
            continue

        for index in range(2,3):
            for i in range(25):
                blob_key = _encode_blob_key(experiment_id='', plugin_name='images',
                                            run=basename, tag='{}/{}'.format(tagname, i), step=0, index=index)
                # print(blob_key)
                address = tensorboard_server_address.format(blob_key)
                # print(address)

                try:
                    contents = urllib.request.urlopen(address, timeout=10).read()
                except urllib.error.HTTPError as e:
                    print('Could not get the image {}.'.format(basename))
                    continue

                if len(contents) == 0:
                    print('No content found for {}'.format(address))

                target_image_basepath_ = os.path.join(target_image_basepath, '{}'.format(i))
                if not os.path.isdir(target_image_basepath_):
                    os.makedirs(target_image_basepath_)
                target_image_path = os.path.join(target_image_basepath_, '{}_{}-{}.png'.format(basename, tagname, i))
                if os.path.isfile(target_image_path):
                    print('The file {} already exists!'.format(target_image_path))
                    continue

                with open(target_image_path, 'wb') as f:
                    f.write(contents)
